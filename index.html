<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>The Surrounding Ocean</title>
        <script>
let language = 'en';
let focus_lid = 'L31761-S1'; // dictionary
let etymon_lids = [];
let derived_lids = [];
let alphaprev_lid = null;
let alphanext_lid = null;
let meaning_ring = [];
let next_meaning_index = null;
let previous_meaning_index = null;
let hyper_lids = [];
let hypo_lids = [];

const entity_cache = {};

const get_entity = async (id) => {
    if ( is_lsid(id) ) {
        id = lid_from_lsid(id);
    }
    if (!(id in entity_cache)) {
        console.log('wikidata', id);
        const response = await fetch('https://www.wikidata.org/wiki/Special:EntityData/' + id + '.json');
        const entities = await response.json();
        const entity = entities.entities[id];
        entity_cache[id] = entity;
    }
    return entity_cache[id];
};

const get_sense = async (lsid) => {
    if ( !is_lsid(lsid) ) {
        return null;
    }
    const lid = lid_from_lsid(lsid);
    const lexeme = await get_entity( lid );
    let sense = null;
    for (const s of lexeme.senses) {
        if ( s.id !== lsid ) continue;
        sense = s;
    }
    return sense;
}

const ask_sparql = async (query) => {
    console.log('sparql', query);
    const queryendpoint = 'https://query.wikidata.org/sparql?format=json&query=';
    const sparql = queryendpoint + (encodeURI(query).replace(/#/g, '%23'));
    const response = await fetch(sparql);
    const answer = await response.json();
    const bindings = answer.results.bindings;
    const lids = [];
    for (const binding of bindings) {
        lids.push(binding.lexeme.value.substr(31));
    }
    return lids;
};

const get_image = async (lid) => {
    lid = lid_from_lsid( lid );
    const lexeme = await get_entity( lid );
    if ('image' in lexeme) {
        return lexeme.image;
    }
    let result = await ask_sparql(`select distinct ?lexeme { {
      wd:${lid} wdt:P18 ?lexeme .
    } union {
        wd:${lid} ontolex:sense ?sense .
        ?sense wdt:P18 ?lexeme .
    } union {
      wd:${lid} ontolex:sense ?sense .
      ?sense wdt:P5137 ?item .
      ?item wdt:P18 ?lexeme .
    } } limit 1`);
    if (result.length === 0) {
        lexeme.image = {
            image_page: null,
            image_link: null
        };
        return lexeme.image;
    }
    result = result[0].slice(20);
    const response = await fetch('https://commons.wikimedia.org/w/api.php?action=query&format=json&prop=imageinfo&titles=File%3A' + result + '&formatversion=2&iiprop=url&origin=*');
    const answer = await response.json();
    const fileurl = answer.query.pages[0].imageinfo[0].url;
    lexeme.image = {
        image_page: 'https://commons.wikimedia.org/wiki/File:' + result,
        image_link: fileurl
    };
    return lexeme.image;
}

const get_wiktionary_from_word = async (word) => {
    const request = "https://bs.wiktionary.org/w/api.php?action=parse&format=json&title=" +
                    encodeURI(word) +
                    "&text=&redirects=1&prop=langlinks&formatversion=2&origin=*";
    const response = await(fetch(request));
    const answer = await response.json();
    for (const langlink of answer.parse.langlinks) {
        if (langlink.lang === language) {
            return langlink.url;
        }
    }
    for (const langlink of answer.parse.langlinks) {
        if (langlink.lang === 'en') {
            return langlink.url;
        }
    }
    for (const langlink of answer.parse.langlinks) {
        return langlink.url;
    }
    return null;
}

const get_wiktionary_from_lid = async (lsid) => {
    const lid = lid_from_lsid(lsid);
    const lexeme = await get_entity(lid);
    if ('wiktionary' in lexeme) {
        return lexeme.wiktionary;
    }
    const lemma = select_text( lexeme.lemmas ).replace(/[\u200E]/g, '').replace(/[\u200F]/g, '');
    const wiktionary = get_wiktionary_from_word( lemma );
    lexeme.wiktionary = wiktionary;
    return lexeme.wiktionary;
}

const get_derived = async (lid) => {
    const lexeme = await get_entity( lid );
    lid = lid_from_lsid(lid);
    // console.log( lexeme );
    if (!('derived' in lexeme)) {
        const derived = await ask_sparql(`select distinct ?lexeme
            { { ?lexeme wdt:P5191 wd:${lid} } UNION { ?lexeme wdt:P5238 wd:${lid} } }`);
        lexeme.derived = derived;
    }
    return lexeme.derived;
};

const get_alphaprev = async (lid) => {
    const lexeme = await get_entity( lid );
    if (!('alphaprev' in lexeme)) {
        const focuslang_qid = lexeme.language;
        const focus_lang = Object.keys( lexeme.lemmas )[0].toLowerCase();
        const focus_lemma = select_text( lexeme.lemmas ).replace(/[\u200E]/g, '').replace(/[\u200F]/g, '');
        const alphaprev_lids = await ask_sparql(`select distinct ?lexeme {
                ?lexeme a ontolex:LexicalEntry .
                ?lexeme wikibase:lemma ?lemma .
                ?lexeme dct:language wd:${focuslang_qid} .
                filter(lang(?lemma) = "${focus_lang}")
                filter(str(?lemma) < "${focus_lemma}")
            } order by desc(?lemma) limit 10`);
        lexeme.alphaprev = alphaprev_lids;
    }
    if (lexeme.alphaprev.length === 0) {
        return null;
    }
    const previous_lexeme = await get_entity( lexeme.alphaprev[ 0 ] );
    if (!('alphanext' in previous_lexeme)) {
        previous_lexeme.alphanext = [ lid_from_lsid(lid) ];
    }
    if (lexeme.alphaprev.length > 1) {
        if (!('alphaprev' in previous_lexeme)) {
            previous_lexeme.alphaprev = lexeme.alphaprev.slice( 1 );
        }
    }
    return lexeme.alphaprev[ 0 ];
};

const get_alphanext = async (lid) => {
    const lexeme = await get_entity( lid );
    if (!('alphanext' in lexeme)) {
        const focuslang_qid = lexeme.language;
        const focus_lang = Object.keys( lexeme.lemmas )[0].toLowerCase();
        const focus_lemma = select_text( lexeme.lemmas ).replace(/[\u200E]/g, '').replace(/[\u200F]/g, '');
        const alphanext_lids = await ask_sparql(`select distinct ?lexeme {
                ?lexeme a ontolex:LexicalEntry .
                ?lexeme wikibase:lemma ?lemma .
                ?lexeme dct:language wd:${focuslang_qid} .
                filter(lang(?lemma) = "${focus_lang}")
                filter(str(?lemma) > "${focus_lemma}")
            } order by asc(?lemma) limit 10`);
        lexeme.alphanext = alphanext_lids;
    }
    if (lexeme.alphanext.length === 0) {
        return null;
    }
    const next_lexeme = await get_entity( lexeme.alphanext[ 0 ] );
    if (!('alphaprev' in next_lexeme)) {
        next_lexeme.alphaprev = [ lid_from_lsid(lid) ];
    }
    if (lexeme.alphanext.length > 1) {
        if (!('alphanext' in next_lexeme)) {
            next_lexeme.alphanext = lexeme.alphanext.slice( 1 );
        }
    }
    return lexeme.alphanext[ 0 ];
};

const select_text = ( arr, lang = language ) => {
    const languages = Object.keys( arr );
    if ( languages.length === 0 ) { return ''; };
    if ( languages.includes( lang )) {
        return arr[ lang ].value;
    } else if ( languages.includes( 'en' )) {
        return arr.en.value;
    } else {
        return arr[ languages[0] ].value;
    }
};

const get_gloss = async ( sense ) => {
    const glosses = sense.glosses;
    const languages = Object.keys( glosses );
    if ( languages.includes( language )) {
        return glosses[ language ].value;
    }
    const item_ids = [];
    if ('P5137' in sense.claims) {
        const items = sense.claims.P5137;
        for (let item_snak of items) {
            if (item_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const item_id = item_snak.mainsnak.datavalue.value.id;
            item_ids.push( item_id );
        }
    }
    if (item_ids.length > 0) {
        for (const item_id of item_ids) {
            const item = await get_entity( item_id );
            if ( language in item.labels && language in item.descriptions ) {
                return item.labels[language].value + '; ' + item.descriptions[language].value;
            }
        }
    }
    if (languages.length === 0) {
        return '';
    }
    return '(' + languages[0] + ': ' + glosses[ languages[0] ].value + ')';
}

const get_items_for_this_sense = async ( qid ) => {
    const item = await get_entity( qid );
    if (!('senses' in item )) {
        const sense_ids = await ask_sparql(`select distinct ?lexeme { ?lexeme wdt:P5137 wd:${qid} }`);
        item.senses = sense_ids;
    }
    return item.senses;
}

const get_predicatees = async ( qid ) => {
    const item = await get_entity( qid );
    if (!('predicatees' in item )) {
        const predicatee_ids = await ask_sparql(`select distinct ?lexeme { ?lexeme wdt:P9970 wd:${qid} }`);
        item.predicatees = predicatee_ids;
    }
    return item.predicatees;
}

const get_hypos_from_sense = async ( sid ) => {
    const sense = await get_sense( sid );
    if ('hypos' in sense) {
        return sense.hypos;
    }
    const hypo_ids = await ask_sparql(`select distinct ?lexeme { ?lexeme wdt:P6593 wd:${sid} }`);
    if (hypo_ids.length > 0) {
        sense.hypos = hypo_ids;
        return sense.hypos;
    }
    const lexeme = await get_entity( sid );
    const focus_lang_qid = lexeme.language;
    const subclass_lexemes = await ask_sparql(`select distinct ?lexeme {
        wd:${sid} wdt:P5137 ?item .
        ?hypo wdt:P279 ?item .
        ?lexeme wdt:P5137 ?hypo .
        ?actual_lexeme ontolex:sense ?lexeme .
        ?actual_lexeme dct:language wd:${focus_lang_qid} .
    }`);
    if (subclass_lexemes.length > 0) {
        sense.hypos = subclass_lexemes;
        return sense.hypos;
    }
    sense.hypos = [];
    return sense.hypos;
}

const get_meaning_ring = async ( lsid ) => {
    const lexeme = await get_entity( lsid );
    if ( !is_lsid(lsid) ) {
        const senses = await get_senses(lsid);
        if ( senses.length === 0 ) {
            return [ [ lsid ], null, null ];
        }
        lsid = senses[0];
    }
    let result = [ lsid ];

    let sense = null;
    for ( const s of lexeme.senses ) {
        if ( s.id !== lsid ) continue;
        sense = s;
    }
    if (sense === null) {
        return [ result, null, null ];
    }

    // console.log(sense);
    if ('P5973' in sense.claims) {
        const synonyms = sense.claims.P5973;
        for (let synonym_snak of synonyms) {
            if (synonym_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const synonym_id = synonym_snak.mainsnak.datavalue.value.id;
            result.push( synonym_id );
        }
    }

    if ('P5972' in sense.claims) {
        const translations = sense.claims.P5972;
        for (let translation_snak of translations) {
            if (translation_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const translation_id = translation_snak.mainsnak.datavalue.value.id;
            result.push( translation_id );
        }
    }

    if ('P5137' in sense.claims) {
        const items = sense.claims.P5137;
        for (let item_snak of items) {
            if (item_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const item_id = item_snak.mainsnak.datavalue.value.id;
            result = result.concat( await get_items_for_this_sense ( item_id ) );
        }
    }

    if ('P9970' in sense.claims) {
        const items = sense.claims.P9970;
        for (let item_snak of items) {
            if (item_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const item_id = item_snak.mainsnak.datavalue.value.id;
            result = result.concat( await get_predicatees( item_id ) );
        }
    }

    // console.log( result );
    result = [...new Set(result)].sort();

    if (result.length === 1) {
        return [ result, null, null ];
    }

    const current_index = result.indexOf( lsid );

    if (result.length === 2) {
        if (current_index === 1) {
            return [ result, 0, null ];
        } else {
            return [ result, null, 1 ];
        }
    }

    let previous = current_index - 1;
    if ( previous < 0 ) {
        previous = result.length - 1;
    }
    let next = current_index + 1;
    if ( next >= result.length ) {
        next = 0;
    }

    return [ result, previous, next ];
};

const get_wikipedia_link = async ( lsid ) => {
    const sense = await get_sense( lsid );

    const item_ids = [];
    if ('P5137' in sense.claims) {
        const items = sense.claims.P5137;
        for (let item_snak of items) {
            if (item_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const item_id = item_snak.mainsnak.datavalue.value.id;
            item_ids.push( item_id );
        }
    }
    for ( const item_id of item_ids ) {
        const item = await get_entity( item_id );
        if (language + 'wiki' in item.sitelinks) {
            return item.sitelinks[ language + 'wiki' ].url;
        }
        if ('enwiki' in item.sitelinks) {
            return item.sitelinks.enwiki.url;
        }
        for (const lang in item.sitelinks) {
            if (lang === 'commonswiki') continue;
            if (!lang.endsWith('wiki')) continue;
            return item.sitelinks[ lang ].url;
        }
    }
    return null;

};

const is_lsid = (lsid) => lsid.includes('-');

const lid_from_lsid = (lsid) => lsid.split('-')[0];

const sid_from_lsid = (lsid) => lsid.split('-')[1];

const put = (field, part, content) => {
    document.getElementById( field + '_' + part ).textContent = content;
};

const hide = (condition, element_id, display = 'block') => {
    if (condition) {
        document.getElementById(element_id).style.display = 'none';
    } else {
        document.getElementById(element_id).style.display = display;
    }
}

const display = async (where, lsid, nosense = false) => {
    let lid = lsid;
    let sid = null;
    let got_lsid = is_lsid( lsid );
    if (got_lsid) {
        lid = lid_from_lsid(lsid);
        sid = sid_from_lsid(lsid);
    } else {
        lid = lsid;
        const senses = await get_senses(lid);
        if ( senses.length === 0 ) {
            sid = null;
        } else {
            sid = sid_from_lsid( senses[0] );
        }
    }
    if ( sid === null) {
        lsid = lid;
    } else {
        lsid = lid + '-' + sid;
    }
    got_lsid |= (where === 'center');

    const lexeme = await get_entity( lid );
    const lexeme_language_qid = lexeme.language;
    const lexeme_language = await get_entity( lexeme_language_qid );

    let lemma = '';
    for (const lemmata in lexeme.lemmas) {
        if (lemma !== '') {
            lemma += ' / ';
        }
        lemma += lexeme.lemmas[lemmata].value;
    }
    const language_label = select_text( lexeme_language.labels );
    const lexical_category_qid = lexeme.lexicalCategory;
    const lexical_category = await get_entity( lexical_category_qid );
    const pos_label = select_text( lexical_category.labels );
    put(where, 'lemma', lemma);
    put(where, 'language', language_label);
    put(where, 'pos', pos_label);

    const senses = lexeme.senses;
    hide((senses.length === 0) || nosense, where + '_sense_dash', 'inline');
    if (nosense) {
        return;
    }
    if (senses.length === 0) {
        put(where, 'sense', '');
        if (where === 'center') {
            hide( true, 'center_sense_link');
        }
    } else if (senses.length === 1) {
        const sense_text = await get_gloss( senses[0] );
        put(where, 'sense', sense_text );
        if (where === 'center') {
            const sense_id = senses[0].id;
            const wikipedia_link = await get_wikipedia_link( sense_id );
            hide( (wikipedia_link === null), 'center_sense_link', 'inline');
            if (wikipedia_link !== null) {
                document.getElementById( 'center_sense_link' ).href = wikipedia_link;
            }
        }
    } else {
        put(where, 'sense', '');
        if (where === 'center') {
            hide(true, 'center_sense_dash');
        }
        let inner = '<ol>';
        for (let i = 1; i <= senses.length; i++) {
            const sense_id = senses[i-1].id;
            let action = '';
            if (where === 'center') {
                action = `onclick="move_to('${sense_id}')" class="clickable"`;
            }
            inner += `
                <li id="${where}-${sense_id}" ${action}>
                    <span id="${where}-${sense_id}-gloss"></span>`;
            if (where === 'center') {
                hide( true, 'center_sense_link');
                const wikipedia_link = await get_wikipedia_link( sense_id );
                if (wikipedia_link !== null) {
                    inner += `&nbsp;&nbsp;<a href="${wikipedia_link}"  target="_blank">` +
                             `<img src="wikipedia.png" class="wikilink" /></a>`
                }
            }
            inner += `&nbsp;`;
        }
        inner += '</ol>';
        const root = document.getElementById (where + '_sense' );
        root.innerHTML = inner;
        for (let i = 1; i <= senses.length; i++) {
            const gloss = await get_gloss( senses[i-1] );
            const sense_id = senses[i-1].id;
            document.getElementById( where + '-' + sense_id + '-gloss').textContent = gloss;
        }
        if (got_lsid) {
            document.getElementById( where + '-' + lsid).classList.add('highlight_sense');
        }
    }
};

const display_list = async (where, lids) => {
    // console.log( lids );
    let inner = '';
    for (let i = 1; i <= lids.length; i++) {
        inner += `
            <div id="${where}${i.toString()}" class="clickable"
                    onclick="animate_to_center('${where}', '${lids[i-1]}')">
                <b id="${where}${i.toString()}_lemma"></b>
                &mdash;
                <i id="${where}${i.toString()}_language"></i>,
                <i id="${where}${i.toString()}_pos"></i>
                <span id="${where}${i.toString()}_sense_dash">&mdash;</span>
                <span id="${where}${i.toString()}_sense"></span>
            </div>`;
    }

    const root = document.getElementById( where );
    root.innerHTML = inner;
    const nosense = (lids.length > 1);
    for (let i = 1; i <= lids.length; i++) {
        await display(where + i.toString(), lids[i-1], nosense);
    }
};

const get_senses = async (lid) => {
    const lexeme = await get_entity( lid );
    const senses = [];
    for (const sense of lexeme.senses) {
        senses.push( sense.id );
    }
    return senses;
};

const next_sense = async () => {
    const senses = await get_senses( focus_lid );
    let current = 0;
    if ( is_lsid(focus_lid) ) {
        current = senses.indexOf( focus_lid );
    }
    if ( current + 1 < senses.length ) {
        move_to( senses[current + 1], true );
    }
};

const previous_sense = async () => {
    const senses = await get_senses( focus_lid );
    const current = senses.indexOf( focus_lid );
    if ( current > 0 ) {
        move_to( senses[current - 1], true );
    }
};

const next_meaning = async () => {
    if ( next_meaning_index === null ) return;
    await animate_to_center( 'meannext', meaning_ring[next_meaning_index] );
}

const next_free_meaning_index = async (current, step) => {
    if ((meaning_ring.length < 4) || (current === null)) {
        return current;
    }
    let countdown = 100;
    let next = current;
    while (countdown-- > 0) {
        next = next + step;
        if (next < 0) {
            next = meaning_ring.length-1;
        }
        if (next >= meaning_ring.length) {
            next = 0;
        }
        if (next === previous_meaning_index) continue;
        if (next === next_meaning_index) continue;
        if (next === meaning_ring.indexOf( focus_lid )) continue;
        return next;
    }
    return current;
}

const mean_switch = async (prev, step) => {
    const index = prev ? previous_meaning_index : next_meaning_index;
    const to = await next_free_meaning_index(index, step);
    // console.log(previous_meaning_index, meaning_ring.indexOf(focus_lid), next_meaning_index, to);
    if (to === index) {
        return;
    }
    if (prev) {
        previous_meaning_index = to;
    } else {
        next_meaning_index = to;
    }
    await display( prev ? "meanprev" : "meannext", meaning_ring[to] );
} 

const previous_meaning = async () => {
    if ( previous_meaning_index === null ) return;
    await animate_to_center( 'meanprev', meaning_ring[previous_meaning_index] );
}

const animate_to_center = async (element, lsid) => {
    document.getElementById( element ).classList.add( 'animate' );
    setTimeout(async () => {
        document.getElementById( element ).classList.remove( 'animate' );
        move_to( lsid );
    }, 500);
}

const move_to = async (lid, same_lexeme = false) => {
    const url = new URL( window.location );
    url.searchParams.set('lid', lid);
    window.history.pushState({ 'lid': lid }, '', url);
    await set_focus(same_lexeme);
}

const get_hypers = async (lsid) => {
    const lexeme = await get_entity( lsid );
    if ( !is_lsid(lsid) ) {
        const senses = await get_senses(lsid);
        if ( senses.length === 0 ) {
            return [];
        }
        lsid = senses[0];
    }
    let sense = null;
    for ( const s of lexeme.senses ) {
        if ( s.id !== lsid ) continue;
        sense = s;
    }
    if (sense === null) {
        return [];
    }

    const result = [];
    // console.log(sense);
    if ('P6593' in sense.claims) {
        const hypers = sense.claims.P6593;
        for (let hyper_snak of hypers) {
            if (hyper_snak.mainsnak.snaktype !== 'value') {
                continue;
            }
            const hyper_id = hyper_snak.mainsnak.datavalue.value.id;
            result.push( hyper_id );
        }
    }
    if (result.length > 0) {
        return result;
    }
    if ('hyper' in sense) {
        return sense.hyper;
    }

    const focus_lang_qid = lexeme.language;
    const hyper_ids = await ask_sparql(`select distinct ?lexeme {
        wd:${lsid} wdt:P5137 ?item .
        ?item wdt:P279 ?hyper .
        ?lexeme wdt:P5137 ?hyper .
        ?actual_lexeme ontolex:sense ?lexeme .
        ?actual_lexeme dct:language wd:${focus_lang_qid} .
    }`);
    sense.hyper = hyper_ids;
    return sense.hyper;
}

const get_hypos = async (lsid) => {
    const lexeme = await get_entity( lsid );
    if ( !is_lsid(lsid) ) {
        const senses = await get_senses(lsid);
        if ( senses.length === 0 ) {
            return [];
        }
        lsid = senses[0];
    }
    let sense = null;
    for ( const s of lexeme.senses ) {
        if ( s.id !== lsid ) continue;
        sense = s;
    }
    if (sense === null) {
        return [];
    }

    const result = get_hypos_from_sense( lsid );
    return result;
}

const cover = (element) => {
    document.getElementById(element + '_cover').style.display = 'block';
    document.getElementById(element + '_empty_cover').style.display = 'none';
};

const uncover = (element) => {
    document.getElementById(element + '_cover').style.display = 'none';
};

const set_focus = async (same_lexeme = false) => {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    if (urlParams.has('lid')) {
        focus_lid = urlParams.get('lid');
    } else {
        focus_lid = 'L31761-S1';
    }
    if (urlParams.has('lang')) {
        language = urlParams.get('lang');
    }

    cover("hyper");
    cover("meanprev");
    cover("meannext");
    cover("hypo");
    if (!same_lexeme) {
        cover("alphaprev");
        cover("derived");
        cover("etymon");
        cover("alphanext");
    }

    await display('center', focus_lid);

    const lexeme = await get_entity( focus_lid );

    (async () => {
        const { image_page, image_link } = await get_image( focus_lid );
        if (image_link !== null) {
            document.getElementById('image').src = image_link;
            document.getElementById('image_link').href = image_page;
        }
        hide((image_link === null), 'image_link');
    })();

    document.getElementById('center_link').href = 'https://www.wikidata.org/wiki/Lexeme:' + lid_from_lsid( focus_lid );

    (async () => {
        const wiktionary_link = await get_wiktionary_from_lid( focus_lid );
        hide((wiktionary_link === null), 'wiktionary_link');
        if (wiktionary_link !== null) {
            document.getElementById('wiktionary_link').href = wiktionary_link;
        }
    })();

    (async () => {
        let no_audio = true;
        for (let form of lexeme.forms) {
            // console.log(form);
            if ('P443' in form.claims) {
                const filename = form.claims.P443[0].mainsnak.datavalue.value;
                // console.log(filename);
                const response = await fetch('https://commons.wikimedia.org/w/api.php?action=query&format=json&prop=imageinfo&titles=File%3A' + filename + '&formatversion=2&iiprop=url&origin=*');
                const answer = await response.json();
                const fileurl = answer.query.pages[0].imageinfo[0].url;
                document.getElementById('player').src = fileurl;
                no_audio = false;
                break;
            }
        }
        hide(no_audio, 'player');
        hide(no_audio, 'play_button', 'inline');
    })();

    (async () => {
        etymon_lids = [];
        if ('P5191' in lexeme.claims) {
            const etymons = lexeme.claims.P5191;
            for (let etymon_snak of etymons) {
                if (etymon_snak.mainsnak.snaktype !== 'value') {
                    continue;
                }
                const etymon_id = etymon_snak.mainsnak.datavalue.value.id;
                etymon_lids.push( etymon_id );
            }
        }
        if ('P5238' in lexeme.claims) {
            const etymons = lexeme.claims.P5238;
            for (let etymon_snak of etymons) {
                if (etymon_snak.mainsnak.snaktype !== 'value') {
                    continue;
                }
                const etymon_id = etymon_snak.mainsnak.datavalue.value.id;
                etymon_lids.push( etymon_id );
            }
        }
        await display_list( 'etymon', etymon_lids );
        hide((etymon_lids.length === 0), 'etymon');
        hide((etymon_lids.length !== 0), 'etymon_empty_cover');
        uncover("etymon");
    })();

    (async () => {
        derived_lids = await get_derived( focus_lid );
        if (derived_lids.length > 0) {
            await display_list( 'derived', derived_lids );
        }
        hide((derived_lids.length === 0), 'derived');
        hide((derived_lids.length !== 0), 'derived_empty_cover');
        uncover("derived");
    })();

    (async () => {
        alphaprev_lid = await get_alphaprev( focus_lid );
        // console.log( alphaprev_lid );
        if (alphaprev_lid !== null) { await display( 'alphaprev', alphaprev_lid ); }
        hide((alphaprev_lid === null), 'alphaprev');
        hide((alphaprev_lid !== null), 'alphaprev_empty_cover');
        uncover("alphaprev");
    })();

    (async () => {
        alphanext_lid = await get_alphanext( focus_lid );
        // console.log( alphanext_lid );
        if (alphanext_lid !== null) { await display( 'alphanext', alphanext_lid ); }
        hide((alphanext_lid === null), 'alphanext');
        hide((alphanext_lid !== null), 'alphanext_empty_cover');
        uncover("alphanext");
    })();

    (async () => {
        [ meaning_ring, previous_meaning_index, next_meaning_index ] = await get_meaning_ring( focus_lid );
        (async () => {
            if (next_meaning_index !== null) {
                await display( 'meannext', meaning_ring[next_meaning_index] );
            }
            hide((next_meaning_index === null), 'meannext');
            hide((next_meaning_index !== null), 'meannext_empty_cover');
            hide((meaning_ring.length < 4), 'meannext_switch_left');
            hide((meaning_ring.length < 4), 'meannext_switch_right');
            uncover("meannext");
        })();
        (async () => {
            if (previous_meaning_index !== null) {
                await display( 'meanprev', meaning_ring[previous_meaning_index] );
            }
            hide((previous_meaning_index === null), 'meanprev');
            hide((previous_meaning_index !== null), 'meanprev_empty_cover');
            hide((meaning_ring.length < 4), 'meanprev_switch_left');
            hide((meaning_ring.length < 4), 'meanprev_switch_right');
            uncover("meanprev");
        })();
    })();

    (async () => {
        hyper_lids = await get_hypers( focus_lid );
        if (hyper_lids.length > 0) {
            await display_list( 'hyper', hyper_lids );
        }
        hide((hyper_lids.length === 0), 'hyper');
        hide((hyper_lids.length !== 0), 'hyper_empty_cover');
        uncover("hyper");
    })();

    (async () => {
        hypo_lids = await get_hypos( focus_lid );
        if (hypo_lids.length > 0) {
            await display_list( 'hypo', hypo_lids );
        }
        hide((hypo_lids.length === 0), 'hypo');
        hide((hypo_lids.length !== 0), 'hypo_empty_cover');
        uncover("hypo");
    })();
};

const play = () => {
    document.getElementById('player').load();
    document.getElementById('player').play();
};

const hide_help = () => {
    document.getElementById('helppage').style.display = 'none';
}

const display_help = () => {
    document.getElementById('helppage').style.display = 'block';
}

const in_search = () => (document.getElementById( 'search_screen').style.display === 'block');

const start_search = () => {
    document.getElementById( 'search_screen').style.display = 'block';
    document.getElementById( 'search' ).focus();
}

const end_search = () => {
    document.getElementById( 'search_screen').style.display = 'none';
}

const do_search = async () => {
    const search_string = document.getElementById( 'search' ).value;
    const query = `https://www.wikidata.org/w/api.php?action=wbsearchentities&` +
                  `format=json&search=${search_string}&language=${language}&` +
                  `type=lexeme&limit=20&props=&formatversion=2&origin=*`;
    const response = await fetch(query);
    const results = await response.json();
    let inner = '<div id="search_results_none">⛞</div>';
    for (const result of results.search) {
        inner += `<div class="search_result" onclick="choose_result('${result.id}')">` + 
            `<strong style="font-size: x-large;">${result.label}</strong> &nbsp;&nbsp;` +
            `<em style="font-size: large;">${result.description}</em>`+
          `</div>`;
    }
    document.getElementById( 'search_results' ).innerHTML = inner;
    hide((results.search.length !== 0), 'search_results_none');
}

const click_search = () => {
    if (in_search()) {
        end_search();
    } else {
        start_search();
    }
}

const in_language = () => (document.getElementById( 'language_screen').style.display === 'block');

const click_language = () => {
    if (in_language()) {
        end_language();
    } else {
        start_language();
    }
}

const start_language = () => {
    document.getElementById( 'language_input' ).value = language;
    document.getElementById( 'language_screen').style.display = 'block';
    document.getElementById( 'language_input' ).focus();
}

const end_language = () => {
    document.getElementById( 'language_screen').style.display = 'none';
}

const set_language = async () => {
    const to_set = document.getElementById( 'language_input' ).value;
    const url = new URL( window.location );
    url.searchParams.set('lang', to_set);
    window.history.pushState({}, '', url);
    end_language();
    labelize_help_screen(to_set);
    await set_focus();
}

const choose_result = async (lid) => {
    end_search();
    move_to(lid);
}

const presskey = () => {
    const key = event.keyCode;
    if ([32, 191, 48, 96].includes(key)) {
        display_help();
    }
}

const pressedkey = () => {
    const key = event.keyCode;
    if (in_search()) {
        if ([13].includes(key)) {
            do_search();
        }
        if ([27].includes(key)) {
            end_search();
        }
        return;
    }
    if (in_language()) {
        if ([13].includes(key)) {
            set_language();
        }
        if ([27].includes(key)) {
            end_language();
        }
        return;
    }
    if ([81, 103, 55].includes(key)) {
        animate_to_center( 'hyper', hyper_lids[0] );
    }
    if ([38, 87, 104, 56].includes(key)) {
        animate_to_center( 'alphaprev', alphaprev_lid );
    }
    if ([69, 105, 57].includes(key)) {
        animate_to_center( 'derived', derived_lids[0] );
    }
    if ([37, 65, 100, 52].includes(key)) {
        previous_meaning();
    }
    if ([39, 68, 102, 54].includes(key)) {
        next_meaning();
    }
    if ([90, 97, 49, 89].includes(key)) {
        animate_to_center( 'etymon', etymon_lids[0] );
    }
    if ([88, 83, 40, 98, 50].includes(key)) {
        animate_to_center( 'alphanext', alphanext_lid );
    }
    if ([67, 99, 51].includes(key)) {
        animate_to_center( 'hypo', hypo_lids[0] );
    }
    if ([188, 109].includes(key)) {
        previous_sense();
    }
    if ([190, 107].includes(key)) {
        next_sense();
    }
    if ([32, 191, 48, 96].includes(key)) {
        hide_help();
    }
    if ([13].includes(key)) {
        start_search();
    }
    if ([27].includes(key)) {
        end_search();
    }
    // console.log(key);
};

const put_item_label = async (field, qid, lang) => {
    const item = await get_entity(qid);
    const label = await select_text(item.labels, lang);
    put(field, 'text', label);
}

const labelize_help_screen = async (lang) => {
    put_item_label('translation', 'Q7553', lang);
    put_item_label('synonym', 'Q1040689', lang);
    put_item_label('compound', 'Q245423', lang);
    put_item_label('etymology', 'Q35245', lang);
    put_item_label('alphabet', 'Q10925', lang);
    put_item_label('hierarchy', 'Q188619', lang);
}

const initialize = async () => {
    await set_focus();

    addEventListener( 'popstate', (event) => {
        set_focus();
    });
    labelize_help_screen(language);
};

        </script>
        <style>
body {
    font-family: Georgia, serif;
    font-size: x-large;
    background-color: linen;
    color: rgb(64, 0, 0);
}
#center {
    position: absolute;
    top: 28%;
    left: 28%;
    height: 44%;
    width: 44%;
    border: thick;
    border-style: double;
    padding: 0.5em;
    overflow: auto;
    box-sizing: border-box;
}
#center_link {
    position: fixed;
    right: calc(29% + 0.2em);
    bottom: 29%;
}
#wiktionary_link {
    position: fixed;
    right: calc(29% + 3.2em);
    bottom: 29%;
}
#hyper {
    position: absolute;
    top: 2%;
    left: 2%;
    height: 25%;
    width: 25%;
    overflow: auto;
}
#hyper_empty_cover {
    display: none;
    position: absolute;
    top: 2%;
    left: 2%;
    height: 25%;
    width: 25%;
}
#hyper_empty {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#hyper_cover {
    position: absolute;
    top: 2%;
    left: 2%;
    height: 25%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#hyper_cover_throbber {
    position: relative;
    text-align: center;
    top: 5%;
    font-size: 200%;
    color: black;
}
#alphaprev {
    position: absolute;
    top: 2%;
    left: 30%;
    height: 25%;
    width: 40%;
    overflow: auto;
}
#alphaprev_empty_cover {
    display: none;
    position: absolute;
    top: 2%;
    left: 30%;
    height: 25%;
    width: 40%;
}
#alphaprev_empty {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#alphaprev_cover {
    position: absolute;
    top: 2%;
    left: 30%;
    height: 25%;
    width: 40%;
    background-color: rgba(250, 240, 230, 0.8);
}
#alphaprev_cover_throbber {
    position: relative;
    text-align: center;
    top: 5%;
    font-size: 200%;
    color: black;
}
#derived {
    position: absolute;
    top: 2%;
    left: 74%;
    height: 25%;
    width: 25%;
    overflow: auto;
}
#derived_empty_cover {
    display: none;
    position: absolute;
    top: 2%;
    left: 74%;
    height: 25%;
    width: 25%;
}
#derived_empty {
    position: relative;
    text-align: center;
    color: rgb(220, 180, 180);
    font-size: 200%;
}
#derived_cover {
    position: absolute;
    top: 2%;
    left: 74%;
    height: 25%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#derived_cover_throbber {
    position: relative;
    text-align: center;
    top: 5%;
    font-size: 200%;
    color: black;
}
#meanprev {
    position: absolute;
    top: 30%;
    left: 2%;
    height: 40%;
    width: 25%;
    overflow: auto;
}
#meanprev_empty_cover {
    display: none;
    position: absolute;
    top: 30%;
    left: 2%;
    height: 40%;
    width: 25%;
}
#meanprev_empty {
    position: relative;
    top: 20%;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#meanprev_cover {
    position: absolute;
    top: 30%;
    left: 2%;
    height: 40%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#meanprev_cover_throbber {
    position: relative;
    text-align: center;
    top: 20%;
    font-size: 200%;
    color: black;
}
#meanprev_switch_left {
    position: absolute;
    top: calc(70% - 2em);
    left: calc(12% - 1em);
}
#meanprev_switch_right {
    position: absolute;
    top: calc(70% - 2em);
    left: calc(12% + 1em);
}
#meannext {
    position: absolute;
    top: 30%;
    left: 74%;
    height: 40%;
    width: 25%;
    overflow: auto;
}
#meannext_empty_cover {
    display: none;
    position: absolute;
    top: 30%;
    left: 74%;
    height: 40%;
    width: 25%;
}
#meannext_empty {
    position: relative;
    top: 20%;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#meannext_cover {
    position: absolute;
    top: 30%;
    left: 74%;
    height: 40%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#meannext_cover_throbber {
    position: relative;
    text-align: center;
    top: 20%;
    font-size: 200%;
    color: black;
}
#meannext_switch_left {
    position: absolute;
    top: calc(70% - 2em);
    left: calc(84% - 1em);
}
#meannext_switch_right {
    position: absolute;
    top: calc(70% - 2em);
    left: calc(84% + 1em);
}
#etymon {
    position: absolute;
    top: 74%;
    left: 2%;
    height: 25%;
    width: 25%;
    display: none;
    overflow: auto;
}
#etymon_empty_cover {
    display: none;
    position: absolute;
    top: 74%;
    left: 2%;
    height: 25%;
    width: 25%;
}
#etymon_empty {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#etymon_cover {
    position: absolute;
    top: 74%;
    left: 2%;
    height: 25%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#etymon_cover_throbber {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: black;
}
#alphanext {
    position: absolute;
    top: 74%;
    left: 30%;
    height: 25%;
    width: 40%;
    overflow: auto;
}
#alphanext_empty_cover {
    display: none;
    position: absolute;
    top: 74%;
    left: 30%;
    height: 25%;
    width: 40%;
}
#alphanext_empty {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#alphanext_cover {
    position: absolute;
    top: 74%;
    left: 30%;
    height: 25%;
    width: 40%;
    background-color: rgba(250, 240, 230, 0.8);
}
#alphanext_cover_throbber {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: black;
}
#hypo {
    position: absolute;
    top: 74%;
    left: 74%;
    height: 25%;
    width: 25%;
    overflow: auto;
}
#hypo_empty_cover {
    display: none;
    position: absolute;
    top: 74%;
    left: 74%;
    height: 25%;
    width: 25%;
}
#hypo_empty {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: rgb(220, 180, 180);
}
#hypo_cover {
    position: absolute;
    top: 74%;
    left: 74%;
    height: 25%;
    width: 25%;
    background-color: rgba(250, 240, 230, 0.8);
}
#hypo_cover_throbber {
    position: relative;
    text-align: center;
    font-size: 200%;
    color: black;
}
.animate {
    animation: move_to_center;
    animation-duration: 400ms;
}
@keyframes move_to_center {
    100% {
        top: 30%;
        left: 30%;
    }
}
audio {
    display: none;
}
.click_button {
    background-color: linen;
    height: 1.5em;
    width: 1.5em;
    text-align: center;
    border-width: thin;
    font-size: xx-large;
    border-radius: 0.2em;
    border-style: dashed;
}
.click_button:hover {
    color: black;
    cursor: pointer;
    background-color: white;
}
#play_button {
    display: none;
    position: fixed;
    bottom: 29%;
    left: 29%;
}
#help_button {
    position: absolute;
    bottom: 0.2em;
    right: 0.2em;
}
#search_button {
    position: absolute;
    bottom: 0.2em;
    right: 1.9em;
}
#documentation_button {
    position: absolute;
    bottom: 0.2em;
    right: 3.6em;
}
#language_button {
    position: absolute;
    bottom: 0.2em;
    right: 5.3em;
}
#image {
    width: 100%;
}
#image_link {
    width: 40%;
    float: right;
    display: none;
}
.clickable:hover {
    color: black;
    cursor: pointer;
    background-color: white;
}
#center_sense_link {
    display: none;
}
ol {
    list-style-position: inside;
    padding: 0em;
    margin-top: 0.2em;
}
li {
    padding-left: 0.2em;
}
.highlight_sense {
    box-shadow: -0.1em 0em 0em 0em rgb(64, 0, 0);
}
#helppage {
    position: absolute;
    background-color: rgba(250, 240, 230, 0.6);
    left: 0%;
    top: 0%;
    height: 100%;
    width: 100%;
    display: none;
}
.helptext {
    font-family: Impact, 'Arial Narrow Bold', sans-serif;
    font-style: italic;
    font-size: 200%;
}
#search_screen {
    display: none;
    position: absolute;
    left: 0%;
    top: 0%;
    width: 100%;
    height: 100%;
    background-color: rgba(250, 240, 230, 0.6);
}
#search {
    position: absolute;
    top: 10%;
    left: 20%;
    width:60%;
    font-size: x-large;
    padding: 0.2em;
    box-sizing: border-box;
    border-radius: 0.2em;
    border-width: 0.1em;
    outline: none;
}
#search_results {
    position: absolute;
    color: black;
    top: 20%;
    left: 20%;
    border-style: solid;
    border-color: black;
    border-radius: 0.2em;
    border-width: 0.1em;
    width: 60%;
    background-color: lightgray;
    height: 70%;
    overflow: auto;
}
#search_results_none {
    display: none;
    text-align: center;
    font-size: 200%;
}
.search_result {
    border: 0.05em;
    padding: 0.4em;
    border-style: solid;
    background-color: white;
}
.search_result:hover {
    background-color: azure;
    cursor: pointer;
}
#language_screen {
    display: none;
    position: absolute;
    left: 0%;
    top: 0%;
    width: 100%;
    height: 100%;
    background-color: rgba(250, 240, 230, 0.6);
}
#language_input {
    position: absolute;
    top: 45%;
    left: 40%;
    width: 4em;
    font-size: x-large;
    padding: 0.2em;
    box-sizing: border-box;
    border-radius: 0.2em;
    border-width: 0.1em;
    outline: none;
}

        </style>
        <link rel="icon" href="favicon32.png" sizes="32x32">
        <link rel="apple-touch-icon" href="favicon180.png">
        <link rel="manifest" href="manifest.webmanifest">
    </head>
    <body onkeydown="presskey()" onkeyup="pressedkey()" onload="initialize()">
        <div id="hyper">
        </div>
        <div id="hyper_cover">
            <div id="hyper_cover_throbber">⏳</div>
        </div>
        <div id="hyper_empty_cover">
            <div id="hyper_empty">⛞</div>
        </div>
        <div id="alphaprev" onclick="animate_to_center('alphaprev', alphaprev_lid)" class="clickable">
            <b id="alphaprev_lemma"></b>
            &mdash;
            <i id="alphaprev_language"></i>,
            <i id="alphaprev_pos"></i>
            <span id="alphaprev_sense_dash">&mdash;</span>
            <span id="alphaprev_sense"></span>
        </div>
        <div id="alphaprev_cover">
            <div id="alphaprev_cover_throbber">⏳</div>
        </div>
        <div id="alphaprev_empty_cover">
            <div id="alphaprev_empty">⛞</div>
        </div>
        <div id="derived">
        </div>
        <div id="derived_cover">
            <div id="derived_cover_throbber">⏳</div>
        </div>
        <div id="derived_empty_cover">
            <div id="derived_empty">⛞</div>
        </div>
        <div id="meanprev" onclick="previous_meaning()" class="clickable">
            <b id="meanprev_lemma"></b>
            &mdash;
            <i id="meanprev_language"></i>,
            <i id="meanprev_pos"></i>
            <span id="meanprev_sense_dash">&mdash;</span>
            <span id="meanprev_sense"></span>
        </div>
        <div id="meanprev_switch_left" class="click_button" onclick="mean_switch(true, -1)">◅</div>
        <div id="meanprev_switch_right" class="click_button" onclick="mean_switch(true, +1)">▻</div>
        <div id="meanprev_cover">
            <div id="meanprev_cover_throbber">⏳</div>
        </div>
        <div id="meanprev_empty_cover">
            <div id="meanprev_empty">⛞</div>
        </div>
        <div id="center">
            <a id="image_link" href="" target="_blank"><img id="image" src="" /></a>
            <b id="center_lemma"></b>
            &mdash;
            <i id="center_language"></i>,
            <i id="center_pos"></i>
            <span id="center_sense_dash">&mdash;</span>
            <span id="center_sense"></span>
            &nbsp;
            <a id="center_sense_link" href="https://www.wikipedia.org" target="_blank"><img src="wikipedia.png" style="height:0.6em;"></a>
            <audio id="player" src=""></audio>
            <button id="play_button" class="click_button" onclick="play();" class="clickable">🔈</button>
            <a id="wiktionary_link" target="_blank" href="https://www.wiktionary.org"><img src="wiktionary.png" style="height:1.5em;"></a>
            <a id="center_link" target="_blank" href="https://www.wikidata.org/wiki/Wikidata:Main_Page"><img src="wikidata.png" style="height:1.5em;"></a>
        </div>
        <div id="meannext" onclick="next_meaning()" class="clickable">
            <b id="meannext_lemma"></b>
            &mdash;
            <i id="meannext_language"></i>,
            <i id="meannext_pos"></i>
            <span id="meannext_sense_dash">&mdash;</span>
            <span id="meannext_sense"></span>
        </div>
        <div id="meannext_switch_left" class="click_button" onclick="mean_switch(false, -1)">◅</div>
        <div id="meannext_switch_right" class="click_button" onclick="mean_switch(false, +1)">▻</div>
        <div id="meannext_cover">
            <div id="meannext_cover_throbber">⏳</div>
        </div>
        <div id="meannext_empty_cover">
            <div id="meannext_empty">⛞</div>
        </div>
        <div id="etymon">
        </div>
        <div id="etymon_cover">
            <div id="etymon_cover_throbber">⏳</div>
        </div>
        <div id="etymon_empty_cover">
            <div id="etymon_empty">⛞</div>
        </div>
        <div id="alphanext" onclick="animate_to_center('alphanext', alphanext_lid)" class="clickable">
            <b id="alphanext_lemma"></b>
            &mdash;
            <i id="alphanext_language"></i>,
            <i id="alphanext_pos"></i>
            <span id="alphanext_sense_dash">&mdash;</span>
            <span id="alphanext_sense"></span>
        </div>
        <div id="alphanext_cover">
            <div id="alphanext_cover_throbber">⏳</div>
        </div>
        <div id="alphanext_empty_cover">
            <div id="alphanext_empty">⛞</div>
        </div>
        <div id="hypo">
        </div>
        <div id="hypo_cover">
            <div id="hypo_cover_throbber">⏳</div>
        </div>
        <div id="hypo_empty_cover">
            <div id="hypo_empty">⛞</div>
        </div>
        <svg id="helppage" width="90%" height="90%">
            <line x1="10%" y1="90%" x2="90%" y2="10%" stroke="red" stroke-linecap="round" stroke-width="1em" />
            <text x="15%" y="92%" transform-origin="15% 92%" transform="rotate(-45)" class="helptext" id="etymology_text">etymology</text>
            <text x="10%" y="82%" transform-origin="10% 82%" transform="rotate(-45)" class="helptext" id="compound_text">compound</text>
            <line x1="10%" y1="10%" x2="90%" y2="90%" stroke="lightblue" stroke-linecap="round" stroke-width="1em" />
            <text x="10%" y="10%" transform-origin="10% 10%" transform="rotate(45)" class="helptext" id="hierarchy_text">hierarchy</text>
            <line x1="10%" y1="50%" x2="90%" y2="50%" stroke="lightgreen" stroke-linecap="round" stroke-width="1em" />
            <text x="5%" y="47%" class="helptext" id="translation_text">translation</text>
            <text x="5%" y="57%" class="helptext" id="synonym_text">synonym</text>
            <line x1="50%" y1="10%" x2="50%" y2="90%" stroke="yellow" stroke-linecap="round" stroke-width="1em" />
            <text x="53%" y="6%" transform-origin="53% 6%" transform="rotate(90)" class="helptext" id="alphabet_text">alphabet</text>
        </svg>
        <div id="search_screen">
            <input id="search" type="text" />
            <div id="search_results">
            </div>
        </div>
        <div id="language_screen">
            <input id="language_input" type="text" />
        </div>
        <button id="language_button" class="click_button" onclick="click_language()">
            <span style="position: absolute; top: 0.3em; left: 0.4em; font-size: large; vertical-align: super;">文</span>
            <span style="position: absolute; bottom: 0.3em; right: 0.4em; font-size: large; vertical-align: sub;">A</span>
        </button>
        <button id="documentation_button" class="click_button" onclick="parent.open('https://www.wikidata.org/wiki/Wikidata:The_Surrounding_Ocean')">?</button>
        <button id="search_button" class="click_button" onclick="click_search()">🔍</button>
        <button id="help_button" class="click_button"
                onmouseenter="display_help()" onmouseleave="hide_help()"
                ontouchstart="display_help()" ontouchend="hide_help()"
                onmousedown="display_help()" onmouseup="hide_help()"
            >✳</button>
    </body>
</html>